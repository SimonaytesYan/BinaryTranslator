# Бинарный транслятор #

Цель работы ускорить исполнение кода, написанного на ассемблере для [программного процессора](https://github.com/SimonaytesYan/SoftCPU). Будем использовать для этого технологию JIT компиляции. Таким образом программа получает на вход исполняемый файл для программного процессора, переводит команды, содержащиеся в нём, в инструкции процессора x86-64, помещая их в выделенный буфер, и исполняет инструкции из этого буфера.

## Запуск проекта ##

После клонирования репозитория нужно создать недостающие папки, использующиеся во время компиляции. Это можно сделать, выполнив команду
```
make create_dir
```
Далее необходимо осуществить сборку проекта.

Чтобы собрать проект в debug режиме воспользуйтесь командой
```
make debug
```

Чтобы собрать проект в release режиме воспользуйтесь командой
```
make release
```

Исполняемый файл будет лежать в папке Exe под названием Translate. При запуске программы в качестве аргумента командной строки необходимо передать название исполняемого файла программного процессора Пример:
```
Exe/Translate Test.sy
```

## Механизм работы программы ##

Программный процессор имел стек вызовов, стек данных, RAM и 4 регистра. Для простоты трансляции, под стек вызовов и RAM были выделены отдельные области памяти. Регистр `rsi` стал стековым регистром для стека вызовов.

Для простоты обращения к RAM указатель на начало блока памяти, выделенного под неё, сохранён в `rdi`. Соответственно, все обращения к памяти должны происходить по смещению, хранящемуся в `rdi`.

В программном процессоре существовали только регистры RAX, RBX, RCX и RDX. Они соответствуют таким же регистрам в x64. Эти 4 регистры мы будем называть пользовательскими регистрами. Остальные регистры x64 - системными.

Гарантируется, что в начале программы все пользовательские регистры равны нулю.

Реализованна стандартная библиотека, включающая в себя реализации инструкций `in` и `out` программного процессора. Реализацию функций можно увидеть в файле Src/Stdlib/Stdlib.cpp. Функция `long long InputNumber10()` соответствует `in`, функция `void OutputNumber10(long long number)` соответствует `out`.\
Было принято решение написать собственную реализацию, вместо стандартных printf и scanf, из соображений производительности. Это является не сильно трудозатратным решением, так как необходимо реализовать только ввод и вывод десятичных чисел.

Компиляция осуществляется в два прохода, для обработки переходов вниз.

Программа завершается инструкцией ret.

Полученные команды помещаются в буфер для последующего исполнения. После завершения компиляции с помощью ассемблерной вставки осуществляется переход на начало выше описанного буфера.

## Перевод ##

<table>
    <thead>
        <tr>
            <th> Команда программного процессора </th> <th> x86-64 инструкции </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td> push reg/mem/num </td> <td> push reg/mem/num </td>
        </tr>
        <tr>
            <td> pop  reg/mem </td> <td> pop reg/mem </td>
        </tr>
        <tr>
            <td> add </td> <td>  pop r9     <br> 
                                 pop r8     <br> 
                                 add r8, r9 <br>
                                 push r8    <br> 
                            </td>
        </tr>
        <tr>
            <td> sub </td> <td>  pop r9     <br> 
                                 pop r8     <br> 
                                 sub r8, r9 <br>
                                 push r8    <br> 
                            </td>
        </tr>
        <tr>
            <td> mul </td> <td>  сохранение регистров rax, rbx        <br> 
                                 pop r8                               <br>
                                 pop rax                              <br>
                                 cqo                                  <br> 
                                 imul r8                              <br>
                                 push rax                             <br>
                                 восстановление сохранённых регистров
                            </td>
        </tr>
        <tr>
            <td> div </td> <td>  сохранение регистров rax, rbx        <br> 
                                 pop r8                               <br>
                                 pop rax                              <br>
                                 cqo                                  <br> 
                                 idiv r8                              <br>
                                 push rax                             <br>
                                 восстановление сохранённых регистров
                           </td>
        </tr>
        <tr>
            <td> in </td> <td> сохранение пользовательских регистров <br>
                               сохранение rsi и rdi                  <br>
                               call InputNumber10                    <br>
                               push rax                              <br>
                               восстановление сохранённых регистров
                          </td>
        </tr>
        <tr>
            <td> out </td> <td> сохранение пользовательских регистров <br>
                               сохранение rsi и rdi                  <br>
                               pop rdi                               <br>
                               call OutputNumber10                   <br>
                               push rax                              <br>
                               восстановление сохранённых регистров
                          </td>
        </tr>
        <tr>
            <td> jmp label </td> <td> jmp label </td> 
        </tr>
        <tr>
            <td> ja label </td> <td> pop r9         <br>
                                     pop r8         <br>
                                     cmp r8, r8     <br>
                                     jle label      <br>
                                </td> 
        </tr>
        <tr>
            <td> jae label </td> <td> pop r9         <br>
                                     pop r8         <br>
                                     cmp r8, r8     <br>
                                     jl label      <br>
                                </td> 
        </tr>
        <tr>
            <td> jb label </td> <td> pop r9         <br>
                                     pop r8         <br>
                                     cmp r8, r8     <br>
                                     jge label      <br>
                                </td> 
        </tr>
        <tr>
            <td> jbe label </td> <td> pop r9         <br>
                                     pop r8         <br>
                                     cmp r8, r8     <br>
                                     jg label      <br>
                                </td> 
        </tr>
        <tr>
            <td> je label </td> <td> pop r9         <br>
                                     pop r8         <br>
                                     cmp r8, r8     <br>
                                     jne label      <br>
                                </td> 
        </tr>
        <tr>
            <td> jne label </td> <td> pop r9         <br>
                                     pop r8         <br>
                                     cmp r8, r8     <br>
                                     je label      <br>
                                </td> 
        </tr>   
        <tr>
            <td> call label </td> <td> Кладём в память [rsi] адрес возврата <br>
                                       add rsi, 8                           <br>
                                       jmp label
                                </td> 
        </tr>
        <tr>
            <td> ret        </td> <td> Кладём в память [rsi] адрес возврата <br>
                                       jmp на полученный адрес
                                </td> 
        </tr>
        <tr>
            <td> hlt        </td> <td> ret </td>
        </tr>
    </tbody>
</table>

Инверсия условных переходов обусловлена необычной реализацией условных переходов в soft CPU

## Ускорение ##

### Оборудование ###
 |||
-------------------|-
**Compiler**           | g++ 11.3.0
**OS**                 | Ubuntu 11.3.0 
**CPU**                | 11th Gen Intel(R) Core(TM) i7-1165G7 @ 2.80GHz

**Флаги компиляции soft CPU**: -O3
**Флаги компиляции JIT**: -O1

Флаги компиляции JIT не оказывают влияние на скорость работы программ, так как замеряется только этап исполнения программы.

### Условия ###

Для тестирования скорости работы программы были выбраны рекурсивный алгоритм вычисления i-го числа Фибоначчи(производился расчёт 32-го числа Фибоначчи) и алгоритм вычисления корней квадратного уравнения. Коды программ на ассемблере для программного процессора размещёны в файлах Examples/NthFib и Examples/QuadraticEqu. Исполняемые файлы для программного процессора этих программы размещён в той же папке под названиями NthFib.sy и QuadraticEqu.sy. В качестве времени бралось среднее значение по нескольким запускам программы на одном и том же входе(повторялся и замерялся только этап исполнения инструкций). Ввод данных программы осуществлялся из файла, путём перенаправления стандартного потока ввода.

Входные данные для расчёта чисел Фибоначчи были одни и те же: число 32. Тест считался 10 раз. Время - среднее по 10 запускам\
Входные данные для расчёта корней квадратного уравнения можно увидеть в файле Data/TestQuadraticSolver. Один тест состоял из вычисления корней для коэффициентов:
| a | b | c |
|---|---|---|
| 1 | -5 |6 |

100000 раз.  То есть один тест - решение 700 квадратных уравнений. 

Этот тест запускался 10 раз. Время - среднее на одном тесте

### Результат ###

Время указано в миллисекундах

| Программа             | Soft CPU      | JIT         | Коэффициент ускорения  |
|-----------------------|---------------|-------------|------------------------|
| Числа Фибоначчи       | 7532 +- 1     | 92.2 +-0.08 |  81.9                  |
| Квадратное уравнение  | 244.89 +- 0.1 | 4.7 +- 0.09 |  1.55                  |

Таким образом, использование технологии JIT ускорило обе программы. Причём расчёт чисел Фибоначчи очень значительно. Это связано с тем, что в этой программе процессор больше всего времени тратит на работу со стеком. В sort CPU был использован программный стек, который очевидно гораздо медленнее аппаратного, который применяется при исполнении инструкций x86-64 процессора.

Ускорение решения квадратного уравнения не такое впечатляющее, так как значительная часть времени работы программы тратиться на ввод и вывод. Операции, которые не ускоряются при использовании x86-64 инструкций, вместо исполнения на программном процессоре.